---
name: backend-engineer
description:
  Write ASP .NET code.
---

# Projects
- {ProjectName}.{Context}.API (Presentation layer)
- {ProjectName}.{Context}.Modules (Domain, Application, Infrastructure)
- {ProjectName}.{Context}.Migrations (Database migrations)
- {ProjectName}.Integration (Files to communicate between microservices/bounded contexts)

# Guidelines
- **CRITICAL**: Strict Adherence to Reference Patterns
  - You MUST strictly mirror the architectural structure, folder organization, and coding patterns found in the reference solution (`GeminiReference.Blog`) and the `SharedKernel`.
  - This applies to **everything**: directory hierarchy, naming conventions, C# constructs (e.g., `record` vs `class`, `required` properties), and even whitespace/formatting.
  - **Do not invent** new patterns or deviate from the existing ones. If the reference uses a specific base class or interface, you must use it too.

- **CRITICAL**: Verification of Base Classes and Contracts
  - **NEVER assume** the existence or signature of a method, class, or interface.
  - **ALWAYS verify** the `SharedKernel` or reference project source code before using a type.
  - Check for:
    - **Exact Class Names**: e.g., `BaseEvent` vs `DomainEvent`.
    - **Exact Method Signatures**: e.g., `Find(id)` vs `FindById(id)`.
    - **Return Types**: e.g., `UseCaseResponse<Unit>` vs `bool` for delete operations.
    - **Inheritance**: e.g., `UpdateUseCase<TRequest, TEntity>` vs generic `BaseUseCase`.
    - **Namespace Imports**: Ensure ALL required namespaces are imported. Do not rely on IDE auto-imports; verify manually.
    - **Service Registration**: Ensure critical extensions are registered in `Program.cs` (`UseWolverineFx`, `UseDefaultExtensions`).
    - **Module Extensions**: Verify that the module's `Extensions` class (e.g., `PostsExtensions.cs`) registers ALL necessary components, including Use Cases, Services, Repositories, Caching, and **specifically any module-level extensions** like `WolverineExtensions` or `AddExceptionHandlers`. Do not omit any registration found in the reference project.
    - **Global API Extensions**: Ensure `Program.cs` includes all global middleware and configurations found in the reference.
    - **App Settings**: Ensure `appsettings.json` and `appsettings.Development.json` mirror the reference project's structure, including Logging levels, Connection Strings (Redis, Kafka), and other service configurations.

- **IMPORTANT**: Implementation Details
  - **Value Objects**: MUST be implemented as `record` types to mirror `SharedKernel` base types (`UuidValueObject`, `StringValueObject`).
  - **Record DTOs**: ALL DTOs MUST be declared as `record` types, NOT `class`. Use `{ get; init; }` properties instead of positional constructor parameters. There are two distinct styles depending on the layer:
    - **API Request DTOs** (e.g., `CreatePostRequestDTO`, `UpdatePostRequestDTO`): Do NOT use `required`. Use `{ get; set; }` with default values (e.g., `= string.Empty`). Validation is handled entirely by FluentValidation validators, not by record invariants.
    - **Use Case DTOs** (e.g., `CreatePostDTO`): Use `required` properties with `{ get; init; }` to enforce invariants at the application layer, since these are constructed programmatically by the Handler.
  - **Partial Updates with Optional<T>**: Update operations MUST use the `Optional<T>` wrapper (from SharedKernel) to distinguish between "field not sent" and "field sent as null". This applies to:
    - **API Request DTOs**: Properties wrapped in `Optional<T>` with `[JsonConverter(typeof(OptionalConverter<T>))]`. The handler uses `HttpPatch`, NOT `HttpPut`.
    - **Use Case DTOs**: Properties also use `Optional<T>`, passed through from the Handler.
    - **Use Cases**: Use `GetValueOrDefault(currentValue)` to merge partial updates with existing entity values.
    - **Criteria (query filters)**: Use `Optional<T>` parameters; only add filters when `HasValue` is true.
    - **Paginate Request DTOs**: Use `OptionalParam<T>` for URL query parameters.
    - **Validators**: Access `.Value` in rules and use `.When(x => x.Property.HasValue)` to skip validation when the field is not sent.
    - **Exception**: Value Objects that inherit from base types with positional constructors (e.g., `PostId(Guid value) : UuidValueObject(value)`) may keep the positional style.
  - **Client-Side ID Generation**: Entity IDs (GUIDs) MUST be generated by the client and sent in the API request. Do NOT use `Guid.NewGuid()` server-side in Use Cases. This ensures testability, idempotency, and consistency. The `CreatePostRequestDTO` must include an `Id` field, which is parsed and passed through `CreatePostDTO` to the Use Case.
  - **Use Case DTOs**: DTOs used for Use Cases must be named `{UseCaseName}DTO` (e.g., `CreatePostDTO` for `CreatePostUseCase`) and must be located inside the Use Case's folder. Do NOT include "UseCase" in the DTO name.
  - **API Request DTOs**: DTOs used as API request inputs (in Handlers) must be named `{Action}{Entity}RequestDTO` (e.g., `CreatePostRequestDTO`, `UpdatePostRequestDTO`, `PaginatePostsRequestDTO`) and must be located in the API layer (inside the Handler's action folder). API DTOs and Use Case DTOs are SEPARATE types — the Handler maps from the API DTO to the Use Case DTO via `MapUseCaseRequest`. Validators validate the API DTO, NOT the Use Case DTO.
  - **Pagination Use Cases**: These Use Cases receive a `Criteria` object (e.g., `PostCriteria`) as input, NOT a DTO. The API Request DTO (`PaginatePostsRequestDTO`) is used only for the API layer and must be mapped to the Criteria in the Handler. Do NOT use generic DTOs with OrderBy/Filters; define them explicitly in the specific DTO. The response DTO (`PaginatePostsResponseDTO`) and order fields enum (`PaginatePostsOrderFields`) also belong in the API layer.
  - **Cleanup**: When moving files or refactoring, DELETE the old files. Do NOT leave empty files or files with just comments.
  - **Controllers**: MUST NOT inherit from `ControllerBase` directly. Use the Handler pattern (`CreateHandler`, `UpdateHandler`, etc.) from `SharedKernel`.
  - **API Validators**: MUST implement FluentValidation validators for all write operations. These validators must be located in the same directory as the Handler. They MUST validate the API Request DTO (e.g., `AbstractValidator<CreatePostRequestDTO>`), NOT the Use Case DTO. Register them in `Program.cs` using `builder.UseFluentValidation<TValidator>()` **only once** per assembly.
  - **Validation Synchronization**: API Validators (FluentValidation) and Domain Value Objects MUST share the same validation logic and constants (e.g., `MIN_LENGTH`, `MAX_LENGTH`). If a Domain Value Object enforces a rule, the corresponding API Validator MUST enforce it too.
  - **Use Case Inheritance**: Inherit from `CreateUseCase`, `UpdateUseCase`, or `DeleteUseCase` for standard CRUD operations. Use `BaseUseCase` ONLY for non-standard/custom business logic that doesn't fit the CRUD patterns.
  - **Domain Exceptions**: ALL domain exceptions MUST inherit from `DomainException` (from `Neuraltech.SharedKernel.Domain.Exceptions`), NOT from `Exception` directly.
  - **Exception Handling**: The `[MapException]` attribute is **DEPRECATED**. All exception-to-HTTP mapping MUST use `BaseExceptionHandler<TException>` (implementing `IExceptionHandler`), following the pattern in `IdAlreadyInDbExceptionHandler`. Key rules:
    - Handlers for common exceptions (`EntityToUpdateNotFoundException` → 404, `EntityToDeleteNotFoundException` → 204, `IdAlreadyInDbException` → 409) are registered globally in SharedKernel's `UseExceptionHandlers()`.
    - **Module-level exception handlers** (e.g., `PostNotFoundExceptionHandler` → 404) are registered in the module's `AddExceptionHandlers()` method in `PostsExtensions.cs`.
    - Domain exceptions that represent **validation-level invariants** (e.g., `InvalidPostTitleLengthException`, `InvalidPostContentsLengthException`) do NOT get custom handlers — they fall through to the `GlobalExceptionHandler` (500), since they should never reach the domain if API validators are working correctly.
    - `GlobalExceptionHandler` MUST always be registered **last** in `UseExceptionHandlers()`, as `IExceptionHandler` handlers are evaluated in registration order.
  - **Localization Strategy**: Localized strings follow a three-tier approach:
    - **SharedLocalization** (SharedKernel): Only global/fallback messages (e.g., `Error_UnhandledException_*`). Lives in `Neuraltech.SharedKernel.Infraestructure.Localization`.
    - **Module-level localization** (API layer): A marker class per module (e.g., `PostsLocalization`) with its `.resx` file, located in `Resources/v1/{Module}/Shared/Localization/`. Contains shared validation messages (e.g., `Validation_FieldShouldNotBeEmpty`, `Validation_FieldTooShort`). Validators inject `IStringLocalizer<PostsLocalization>`.
    - **Handler-level localization** (API layer): Each handler (e.g., `CreatePostHandler`) has its own `.es.resx` file alongside its `.cs` file, containing domain error keys (e.g., `Error_IdAlreadyInDb_Detail`). Exception handlers resolve these via `BaseExceptionHandler.GetLocalizer(controllerType)`.
    - `.resx` files are resolved by `IStringLocalizerFactory` using the type's namespace relative to the project's `RootNamespace` — no `ResourcesPath` configuration needed.
  - **EF Core Models**: Model classes MUST include `[Required]` and `[MaxLength]` data annotations referencing the corresponding Value Object constants (e.g., `[MaxLength(PostTitle.MAX_LENGTH)]`). This ensures correct migration generation.
  - **Cache Naming**: The `CacheName` property in cached repositories and the `UseFusionCache()` call MUST follow the pattern `"{ServiceName}.{Module}"` (e.g., `"Backoffice.Posts"`, `"Blog.Posts"`).
  - **Event Handlers**: Event Handlers (e.g., for Domain Events) must be implemented as separate classes implementing `IWolverineHandler` (if available) or following Wolverine conventions, delegating the logic to a dedicated Use Case (e.g., `PublishPostCreatedIntegrationEventUseCase`). Do NOT put logic directly in the handler.
  - **Integration Events**: Integration Events MUST follow these conventions:
    - Use `required` properties with `{ get; init; }` — do NOT use positional constructors.
    - Entity IDs MUST be prefixed with the entity class name (e.g., `PostId`, NOT `Id`) to avoid collisions with the event's own ID.
    - `PublicMessageName` MUST be declared as `static readonly string` (NOT `const` or expression-bodied) with PascalCase dot-delimited format: `"GeminiReference.{Service}.{Module}.{EventName}"` (e.g., `"GeminiReference.Backoffice.Posts.PostCreated"`).
  - **Unnecessary Imports**: Do NOT leave unused `using` directives. When refactoring or moving types, always clean up imports that are no longer referenced.
  - **Health Checks**: `Program.cs` MUST register health checks for ALL infrastructure dependencies used by the microservice. At minimum, this includes `.AddNpgSql()` for the database, `.AddRedis()` for Redis, and `.AddKafka()` for Kafka. Both microservices (Blog and Backoffice) use all three.
- Always look into each project's README.md file to understand the project's structure and how to use it.
- Always use [this library](https://github.com/NeuraltechSA/Neuraltech.SharedKernel) as SharedKernel. Currently, it won't be imported as a library, but instead, as a remote project reference (path can be found in solution file).
- Never put infraestructure code in Domain or Application layer, with the exception of wolverine event handler interface, which is used in application layer. Always put it in Infrastructure layer. The direction of imports must be: Domain -> Application -> Infrastructure.
- Don't generate documentation for the code. Only generate code.
- Don't generate tests.
- Rate limiting, CORS, Auth, etc, won't be implemented in this layer. They will be implemented via API Gateway.
- Integration write events in Backoffice, in sample microservice, are for example purposes only. It's not mandatory to publish them together with snapshots, but it's allowed.
- **Snapshot Strategy**:
  - **Internal vs External**: Distinguish between **Domain Snapshots** (internal state for Memento pattern, used for hydration/rehydration) and **Integration/Public Snapshots** (external contracts for other services).
  - **Decoupling**: Domain entities MUST NOT depend on Integration projects or types. To achieve this, use the **Separation of Concepts** pattern:
    1.  Define a local `PostSnapshot` in the Domain layer for internal state.
    2.  Define a separate `PostPublicSnapshot` in the Integration project for external consumption.
    3.  In the Application layer (`PublishPostSnapshotUseCase`), map the Domain Snapshot to the Integration Snapshot manually.
  - **Naming**: Integration snapshots must be suffixed with `PublicSnapshot` (e.g., `PostPublicSnapshot`) to clearly distinguish them from domain snapshots and avoid ambiguity.
  - **Publisher**: Use the generic `ISnapshotPublisher.Publish<T>(T snapshot)` method to publish the integration snapshot. do NOT force the Entity to implement `ISnapshotable` for the integration type, as this causes circular dependencies.